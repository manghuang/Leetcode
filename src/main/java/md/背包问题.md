## 1、01背包问题

#### 1.1、什么是01背包问题？

> 给定n个物体，这n个物体的价值分别为{v1、v2、...、vn}，这n个物品的重量分别为{w1、w2、...、w3}，现在有一个背包，这个背包可以承受的重量为w，你要从n个物品中选取物品放入背包中，在保证背包不会撑破的情况下，你可以获得的最大价值是多少？

#### 1.2、可能解法和时间复杂度分析

​		解法一：枚举所有的可能情况，因为对于一个物品只有放入和不放入两种情况，所以共有2^n种情况，所以可以得到解法一，通过dps来模拟。dps的解答过程可以看作是深度优先遍历一个巨大的二叉树，同时这个dps用的是回溯的方法，计算是从子节点到根节点。

```java
 private int dps(参数) {
        if(满足截至条件){
            return 0;
        }
        //不要第i个物品
        int noRes = dps(参数);
        //要第i个物品
        int yesRes;
        if(是否满足要这个物品的条件){
           yesRes = dps(参数) + wi;
        }
        return Math.max(noRes, yesRos);
    }
```

​		解法一存在的问题：时间复杂度为O(2^n)，耗时太长，分析问题在于子问题的重复计算，所以考虑通过一个dp数组记录中间计算值，以空间换时间来优化。

```java
private int[][] dp; 
private int dps(参数) {
        if(满足截至条件){
            return 0;
        }
        //不要第i个物品
        int noRes;
     	if(dp数组中已经有下一层的计算结果){
            noRes = 从中取出；
        }else{
            noRes = dps(参数);
        }
        //要第i个物品
        int yesRes;
     	if(dp数组中已经有下一层的计算结果){
            yesRes = 从中取出；
        }else{
            if(是否满足要这个物品的条件){
          	 	yesRes = dps(参数) + wi;
        	}
	    }
     	将本层计算的结果存入dp数组中
        return Math.max(noRes, yesRos);
    }
```

​		解法二、以上的dps优化通过存储子问题的解，相当于对二叉树进行了剪枝，所以时间复杂度大幅度降低。将以上的思路进行发展就可以转换为动态规划的方式，见第二部分。

## 2、动态规划解一个限定条件的01背包问题

#### 2.1、一般解法

> 一个限定条件的含义：在上面的例子中，对于背包只有一个重量w的限制，求得是满足w条件下得最大价值v

​		需要一个二维数组dp[ ] [ ]来记录计算子问题得解，dp[ i ] [ j ]的含义是 从前i个物品中进行选择，组合的重量和<=j 时候可以获得的最大价值。

```java
int[][] dp;
dp[0][] = 0;
dp[][0] = 0;
for (int i = 1; i < n; i++) {
    for(int j = 1; j < w; j++){
        //放不下
	   if(j < wi){
            dp[i][j] = dp[i-1][j];
        }
        //放得下
        else{
            dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-wi]);
	    }
    }
}
```

​		以上过程即是一个填dp数组的过程，图解为：

![1](.\1.png)

#### 2.2、优化解法

​		思想：观察上面代码，会发现i层的计算过程，只与i-1层有关，所以可以优化为使用一维数组dp[ ]来不断迭代，这中情况下需要从w->0方向遍历。

## 3、动态规划解两个限定条件下的01背包问题

#### 3.1、一般解法

> 两个限定条件的含义：在上面的例子中，如果改成给背包增加一个体积t的限制，那么求得是满足w、t条件下得最大价值v

​		需要一个三维数组dp[ ] [ ] [ ]来记录计算子问题得解，dp[ i ] [ j ] [ k ]的含义是 从前i个物品中进行选择，组合的重量和<=j ，组合的体积和<=k时候可以获得的最大价值。

​		具体过程与一个限定条件下类似。

#### 3.2、优化解法

​		思想：与一个限定条件下思想类似，优化为二维数组。

## 4、针对leetcode上的那个题

#### 4.1、分析

​		物品即为字符串，n=字符串的个数，每个字符串有0个数为mi，有1个数为ni，价值即为它的个数1，背包的两个限制条件即为m和n。

​		所以可以看出这是一个有两个限制条件下的01背包问题。

